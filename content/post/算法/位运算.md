---
title: "位运算"
date: 2019-12-04T11:24:48+08:00
lastmod: 2019-12-04T11:24:48+08:00
draft: false
tags: ['位运算']
categories: ['算法']
---

# 原码、补码和反码

 所谓原码就是机器数，是加了一位符号位的二进制数，正数符号位为0，负数符号位为1，计算机中存储、处理、运算的数据通常是8位、16位、32位或64位的，这里以最简单的8位为例讲解。注意符号位是包含在8位中的其中1位，故可直观读出的数只有7位（只有后7位数可以按权展开）。有心人可能注意到原码是有缺陷的，它只能表示255种状态，因为00000000（＋0）和10000000（－0）其实是一个数，因此原码的表示范围成了－127到＋127，这个问题需要神奇的补码来解决，因为在补码中10000000被用来表示－128。

所谓反码，英语里又叫ones' complement（对1求补），这里的1，本质上是一个有限位计数系统里所能表示出的最大值，在8位二进制里就是11111111，在1位十进制里就是9，在3位十六进制里就是FFF（再大就要进位了）。**求反又被称为对一求补，用最大数减去一个数就能得到它的反**，很容易看出在二进制里11111111减去任何数结果都是把这个数按位取反，0变1，1变零，所以才称之为反码。**用原码求反码的方法是，正数不变，负数保留符号位1不变，剩下位按位取反。**

所谓补码，英语里又叫two's complement（对2求补），这个2指的是计数系统的容量（模），就是计数系统所能表示的状态数。对1位二进制数来说只有0和1两种状态，所以模是10也就是十进制的2，对7位二进制数来说就是10000000，这个模是不可能取到的，因为位数多一位。**用模减去一个数（无符号部分）就能得到这个数的补**，比如10000000－1010010=0101110，事实上因为10000000=1111111+1，稍加改变就成了（1111111－1010010）+1，所以又可以表述为先求反再加1。**总结求补码的方法就是正数依旧不变，负数保留符号位不变，先求反码再加上1。**

顺便一提，在计算机中，**负数的表达方式就是它绝对值的补数**！本质上说是用一部分正数来表示负数，这才来了符号位。因此，对于-128而言，其补码就是256-abs(-128)=128，亦即1000 0000。

引入补码的主要原因化减法为加法！

# 移位运算符 

- \>> is the arithmetic (or signed) right shift operator.
- \>>> is the logical (or unsigned) right shift operator.
- << is the left shift operator, and meets the needs of both logical     and arithmetic shifts.

逻辑右移是左边补0，而算术右移是补符号位。

对于正数而言，左移相当于乘2，右移相当于除2。因此移位可以一定程度上替代乘除运算。